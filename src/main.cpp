#include <iostream>
#include <cmath>
#include "BitVector.hpp"


using namespace bv;


int main(int argc, char *argv[]) {
	std::cout << "Hello, World!" << std::endl;
	
	// ========================================================================================
	// getBits
	int8_t a_bits[] = {51, -1, 1, 15, 127, -128};
	// a_bits = {00110011, 11111111, 00000001, 00001111, 01111111, 10000000} - перевели в 2 с.с.
	// 11001100.11111111.10000000.11110000.11111110 - то как по-сути выглядит бит-вектор (точки для удобства восприятия)
	BitVector<int8_t> a_v = BitVector<int8_t>(sizeof(int8_t) * BITS_IN_BYTE * 6, a_bits);
	int8_t *a_field = a_v.getBits(sizeof(int8_t) * BITS_IN_BYTE * 3, 4);
	// 1100.110011111111100000001111.000011111110 - отделил точками получаемое бит-поле согласно его размеру и смещению
	// 11001111.11111000.00001111 - то как по-сути выглядит бит-поле
	// a_field = {11110011, 00011111, 11110000} - то как это бит поле будет выглядеть в рамках массива элементов типа int8_t
	// a_field = {-13, 31, -16} - перевели в 10 с.с.
	std::cout << "Test1: " << (int) a_field[0] << " " << (int) a_field[1] << " " << (int) a_field[2] << std::endl;
	// ========================================================================================
	
	
	// ========================================================================================
	// getFewBits
	int8_t b_bits[] = {51, -1, 1, 15, 127, -128};
	// b_bits = {00110011, 11111111, 00000001, 00001111, 01111111, 10000000} - перевели в 2 с.с.
	// 11001100.11111111.10000000.11110000.11111110 - то как по-сути выглядит бит-вектор (точки для удобства восприятия)
	BitVector<int8_t> b_v = BitVector<int8_t>(sizeof(int8_t) * BITS_IN_BYTE * 6, b_bits);
	int32_t b_bit_var = b_v.getFewBits<int32_t>(sizeof(int8_t) * BITS_IN_BYTE * 3, 4);
	// 1100.110011111111100000001111.000011111110 - отделил точками получаемое бит-поле согласно его размеру и смещению
	// 11001111.11111000.00001111 - то как по-сути выглядит бит-поле (точки для удобства восприятия)
	// b_bit_var = 00000000.11110000.00011111.11110011 - то как это бит поле будет выглядеть в рамках одного элемента типа int32_t
	// Понимаю, это представление может показаться старнным и некорректным, но это было сделано для общей согласованности с классом BitVector,
	// ибо в его реализациях счёт идёт от младшего бита каждой переменной.
	// Т.е. индексация битов внутреннего массива BitVector.bits_ по отношению к самому бит-вектору, выглядит так (при использовании типа данных int8_t):
	// {[7, 6, 5, 4, 3, 2, 1, 0], [15, 14, 13, 12, 11, 10, 9, 8]} и т.п.
	// b_bit_var = 15736819 - перевели в 10 с.с.
	std::cout << "Test2: " << b_bit_var << std::endl;
	// И говоря о том самом согласовании расположения битов в результате работы метода getFewBits и в классе BitVector, привожу пример ниже:
	int32_t b_bits_[] = {b_bit_var};
	BitVector<int32_t> b_v_ = BitVector<int32_t>(sizeof(int32_t) * BITS_IN_BYTE * 1, b_bits_);
	// В данном бит-векторе b_v_ нулевой бит равен 1, второй тоже 1, третий 0 и т.д. Именно так и выглядит бит-поле, описанное на строке 35.
	int8_t b_bit_var_ = b_v.getFewBits<int8_t>(1, 0);
	std::cout << "Test3: " << (int) b_bit_var_ << std::endl;
	// Выводим значение нулевого бита, он равен 1, а не 0. Т.е. b_bit_var (b_bits_) записалась в b_v_ как бы наоборот.
	// Теперь объясняю зачем было так делать. Положим сделали мы не так, а всё проще, записав в b_bit_var 11001111.11111000.00001111,
	// а не 11110000.00011111.11110011. Тогда возникает следующая ситуация:
	// Создаём бит-вектор на основе числа 1 (00000001). Нулевой бит в таком векторе равен 1, что очевидно. Т.е. фактически бит вектор выглядит так:
	// 10000000. Пользуемся функцией getFewBits(8, 0) (размер = 8, смещение = 0) и на выходе получаем число -128 (10000000). Что странно, ведь передавали в конструктор 1.
	// Поэтому тут либо вовсе менять концепцию отображения массива интегрального типа на бит-вектор, либо делать так. Если поменять концепцию,
	// то следует считать биты начиная со старшего, т.е. при создании бит-вектора на основе чила 1, получаем не 10000000, а 00000001.
	// В моей концепции нулевой бит числа - есть нулевой бит бит-вектора.
	// ========================================================================================
	
	
	// ========================================================================================
	// toString
	int8_t с_bits[] = {1};
	// b_bits = {01101001, 11111111, 00000001} - перевели в 2 с.с.
	// 10010110.11111111.10000000 - то как по-сути выглядит бит-вектор (точки для удобства восприятия)
	BitVector<int8_t> с_v = BitVector<int8_t>(sizeof(int8_t) * BITS_IN_BYTE * 1, с_bits);
	std::cout << "Test4: " << с_v.toString() << std::endl;
	// Тут я вижу два варианта вывода бит-вектора, используя мою концепцию отображения массива на бит-вектор:
	// Вар1. 69 ff 01 (моя реализация)
	// Вар2. 96 ff 80
	// Мною был выбран первый варинта, чтобы при создании вектра на основе числа 1 (00000001) мы получали строку 0x01, 
	// а не 0x80 (если переводить сам вектор, который равен 10000000).
	// ========================================================================================
	
	std::cout << "Bye!" << std::endl;
	return 0;
}
